Excellent question â€” et bravo, tu es clairement **au bon niveau pour structurer minishell proprement**.
Je vais te donner **UNE ROADMAP COMPLÃˆTE, Ã‰TAPE PAR Ã‰TAPE**, **pensÃ©e pour 42**, **avec le core + les bonus**, **dans le bon ordre**, et avec **ce que chaque Ã©tape doit produire**.

ğŸ‘‰ Si tu suis cette roadmap, **tu Ã©vites 90 % des piÃ¨ges**.

---

# ğŸ§­ ROADMAP COMPLÃˆTE â€” MINISHELL (CORE + BONUS)

---

## ğŸŸ¦ PHASE 0 â€” PRÃ‰PARATION (Ã  faire AVANT de coder)

### 0.1 Lire bash comme une SPEC

Tester :

```sh
echo "a | b"
ls > file
ls || echo fail
(ls || echo fail) && echo ok
```

ğŸ“Œ Note :

* messages dâ€™erreurs
* comportement ctrl-C / ctrl-D
* prioritÃ© opÃ©rateurs

---

### 0.2 Architecture du projet (CRUCIAL)

```
minishell/
â”œâ”€â”€ includes/
â”‚   â””â”€â”€ minishell.h
â”œâ”€â”€ lexer/
â”œâ”€â”€ parser/
â”œâ”€â”€ expander/
â”œâ”€â”€ executor/
â”œâ”€â”€ builtins/
â”œâ”€â”€ signals/
â”œâ”€â”€ env/
â”œâ”€â”€ utils/
â””â”€â”€ main.c
```

ğŸ‘‰ **Un dossier = une responsabilitÃ©**

---

## ğŸŸ© PHASE 1 â€” STRUCTURES DE DONNÃ‰ES

### 1.1 Tokens (lexer)

```c
t_token
t_token_type
```

### 1.2 AST (parser)

âœ” ce que tu as dÃ©jÃ  commencÃ© ğŸ‘

* NODE_CMD
* NODE_PIPE
* NODE_REDIR_*
* NODE_AND / NODE_OR

### 1.3 Environnement

* copier `envp`
* liste chaÃ®nÃ©e ou tableau dynamique

---

## ğŸŸ¨ PHASE 2 â€” LEXER (CORE)

ğŸ¯ Objectif : `char *` â†’ `t_token *`

### Ã€ implÃ©menter dans cet ordre :

1. Ignorer espaces
2. WORD
3. Quotes simples
4. Quotes doubles
5. Pipes `|`
6. Redirections `< > << >>`
7. DÃ©tection erreurs lexicales :

   * quotes non fermÃ©es

ğŸ“Œ Ã€ la fin :

```c
t_token *lexer(char *input);
```

---

## ğŸŸ§ PHASE 3 â€” PARSER (CORE)

ğŸ¯ Objectif : `t_token *` â†’ `t_ast *`

### Grammaire CORE :

```txt
pipeline â†’ command (| command)*
command â†’ WORD* redirection*
redirection â†’ (< > << >>) WORD
```

### Ordre de dev :

1. `parse_command()`
2. `parse_redirection()`
3. `parse_pipeline()`

ğŸ“Œ Gestion des erreurs syntaxiques :

* pipe en dÃ©but / fin
* redirection sans fichier
* opÃ©rateurs consÃ©cutifs

---

## ğŸŸ¥ PHASE 4 â€” EXPANDER (CORE)

ğŸ¯ Objectif : modifier les tokens WORD

### Ã€ gÃ©rer :

1. `$VAR`
2. `$?`
3. Quotes :

   * simple âŒ expansion
   * double âœ… expansion

ğŸ“Œ Fonction clÃ© :

```c
void expand_tokens(t_token *tokens);
```

---

## ğŸŸª PHASE 5 â€” BUILTINS (CORE)

ImplÃ©menter **avant lâ€™exec**.

### Builtins :

* echo (-n)
* cd
* pwd
* export
* unset
* env
* exit

ğŸ“Œ Important :

* `cd`, `export`, `unset`, `exit` â†’ **doivent sâ€™exÃ©cuter dans le parent**

---

## ğŸŸ« PHASE 6 â€” EXECUTOR (CORE)

ğŸ¯ Objectif : exÃ©cuter lâ€™AST

### Ordre :

1. Commande simple
2. Redirections
3. Pipes
4. Builtins
5. execve + PATH

ğŸ“Œ Fonctions :

```c
int exec_ast(t_ast *node);
```

---

## ğŸŸ¨ PHASE 7 â€” SIGNAUX (CORE)

ğŸ¯ Objectif : comportement bash-like

### Ã€ gÃ©rer :

* SIGINT (ctrl-C)
* SIGQUIT (ctrl-)
* EOF (ctrl-D)

ğŸ“Œ RÃ¨gles :

* 1 variable globale `g_signal`
* handlers minimalistes

---

## ğŸŸ¦ PHASE 8 â€” HISTORIQUE & READLINE

* readline()
* add_history()
* pas de leaks dans ton code

---

# â­ BONUS PART

---

## ğŸŸ© BONUS 1 â€” AND / OR (`&&`, `||`)

### Nouvelle grammaire :

```txt
expression â†’ pipeline ( (&& || ||) pipeline )*
```

### Parser :

* `parse_expression()`
* prioritÃ© : `|` > `&&` `||`

---

## ğŸŸ¨ BONUS 2 â€” ParenthÃ¨ses

```sh
(ls || echo fail) && echo ok
```

### Ã€ ajouter :

* TOKEN_LPAREN `(`
* TOKEN_RPAREN `)`
* rÃ©cursion dans le parser

---

## ğŸŸ§ BONUS 3 â€” Wildcards `*`

### Dans lâ€™expander :

* remplacer `*` par fichiers du cwd
* utiliser `opendir`, `readdir`
* matcher `*.c`

---

## ğŸŸ¥ BONUS 4 â€” PrioritÃ©s correctes

| OpÃ©rateur | PrioritÃ© |   |     |
| --------- | -------- | - | --- |
| ()        | max      |   |     |
|           |          |   |     |
| &&        |          |   | min |

---

# ğŸ§  CHECKLIST FINALE (avant soutenance)

âœ” Pas de global sauf signal
âœ” Pas de leaks
âœ” Messages dâ€™erreur bash-like
âœ” Ctrl-C propre
âœ” Builtins dans le parent
âœ” Parser sÃ©parÃ© du lexer
